import React, {useState, useEffect} from 'react'; 
import { Redirect, Route } from 'react-router-dom';
import Button from '@material-ui/core/Button';
import AutoGenKeys from './autoGenKeys'; 


const PrimeGen = (..._props: any[]) => {
    const [loading, setLoading] = useState<Boolean>(false); 

    const [primeArr, setPrimeArr] = useState<Array<number>>([]);
    const [randoPrime1, setRandoPrime1] = useState<number>(1);
    const [randoPrime2, setRandoPrime2] = useState<number>(1);
    const [e, setE] = useState<number|string>(0);
    const [d, setD] = useState<number|string>(0);
    const [N, setN] = useState<number>(primeArr[randoPrime1] * primeArr[randoPrime2]);

    const [genPrimesDisplay, setGenPrimesDisplay]=useState(true);
    const [genEDisplay, setGenEDisplay]=useState<string>('none');
    const [genDDisplay, setGenDDisplay]=useState<string>('none');
    const [autoGenerateKeys, setAutoGenerateKeys]=useState<string>('none');
    const [randomPrimesDisplay, setRandomPrimesDisplay]=useState<string>('none'); 
    const [displayOK, setDisplayOK]=useState<string>('none');
    const [successD, setSuccessD]=useState<string>('none');
    const [mainGenerator, setMainGenerator]=useState<string>('inline-block');
    const [finalCryptoPairs,setFinalCryptoPairs]=useState<FinalCryptoPairs>({
        N:0, e:0, d:0
    }); 

    const [test,setTest] = useState(null)
    const [inputValue, setInputValue] = useState(null)

    interface FinalCryptoPairs {
        N: Number; 
        e: Number|string;
        d: Number|string; 
    }

    useEffect(() => {

        let primes = genPrimeArr()
        setPrimeArr(primes)

        return () => {}

    }, [primeArr, randoPrime1, randoPrime2, displayOK]); 

    const handleSubmit = (e: { preventDefault: () => void; target: { parentNode: { value: any }[] } }) => {
        e.preventDefault();
        setInputValue(e.target.parentNode[0].value);
        console.log('inputValue e -> ', e.target.parentNode[0].value);
    }
    const handleManually = () => {
        setLoading(false); 
        setRandomPrimesDisplay('inline-block'); 
        setAutoGenerateKeys('none');
    }
    const handleAutomatically = () => {
        setAutoGenerateKeys('inline-block'); 
        setRandomPrimesDisplay('none'); 
        setGenEDisplay('none');
        setGenDDisplay('none'); 
    }
    const handleOK = () => {
        setDisplayOK('none')
        setPrimeArr([]);
        setE(0)
        setD(0)
    }

    //-------------------------------------
    const genPrimeArr = () => {
        // some max prime number firstN, can also be higher
        // will run into time propblems if too high 
        let firstN = 149
        for (let n = firstN; n >= 2; n--) {
            let checker = true
            for(let i=2;i<firstN/2;i++){
                if(n!==i) {
                    if((n % i) === 0){
                        checker = false
                        break // not a prime num 
                    }                    
                }
            }
            if(checker === true){
                primeArr.push(n)
            }
        }
        return primeArr          
    }
    //-------------------------------------
    const genRandomPrimes = () => {
        let random1 = Math.floor(Math.random()*(primeArr.length)) 
        setRandoPrime1(random1)
        let random2 = Math.floor(Math.random()*(primeArr.length)) 
        setRandoPrime2(random2)

        if(random2==random1){
            while(random2==random1){
                random2 = Math.floor(Math.random()*(primeArr.length)) 
            }
            setRandoPrime2(random2)
        }
        if(e!==undefined) setE(0)
        if(d!==undefined) setD(0)
        if(!d && e!==undefined) setGenDDisplay('none')
        if(d!==undefined && e!==undefined) setGenDDisplay('none')
        if(displayOK==='inline-block') setDisplayOK('none')
        
        setGenEDisplay('inline-block');
    }
    //-------------------------------------
    const genE = () => {
        let genE = generateE();
        setE(genE);
    }
    const genD = () => {
        let genD = generateD()
        setD(genD) 
    }
    const autoGenD = () => {
        setLoading(true); 

        // let autoGenD = Number(autoGenerateD());
        // setD(autoGenD); 
    }
    //-------------------------------------
    const gcd = (a:number, b:number):number => {
        if (!b) {
            return a;
        }
        let aModB:number = a % b; 
        // return gcd (b, a%b)
        return gcd ( b, aModB );
    }
    //-------------------------------------
    const generateE = () => {
        // e is gt 1 and lt Phi(N)
        // e is coprime with N and Phi(N)
        let findE; 
        if(randoPrime1 || randoPrime2){
            let N = primeArr[randoPrime1] * primeArr[randoPrime2]
            console.log('N -> ', N)
            let phiN = (primeArr[randoPrime1] - 1) * (primeArr[randoPrime2] - 1)
            console.log('phiN -> ', phiN)
            
            findE = Math.floor(Math.random()*(phiN-2)+2)
            console.log("  e before-> ", findE)

            while(gcd(findE,N)!==1 && gcd(findE,phiN)!==1){
                findE--
            }
            console.log("  after-> ", findE)
            setGenDDisplay('inline-block')
            return findE
        } else {
            return 0
        }
    }
    //-------------------------------------
    const generateD = () => {
        // d*e = 1 mod N 
        let dd:number|string=1; 
        if(e !== null){
            let phiN = (primeArr[randoPrime1] - 1) * (primeArr[randoPrime2] - 1)
            while( ((dd*Number(e)) % phiN !== 1) && dd<10000 ){
                console.log('d -> ', (dd*Number(e)) % phiN)
                if((dd*Number(e)) % phiN === 1 ){
                    console.log("FOUND ONE D ",dd)
                    break
                }
                dd++
            }
            if(dd===10000){
                dd = ('Computation > 10000. Try Again.')
                // setD('Computation is larger than 10000. Try Again.')
                setGenEDisplay('none');
                setGenDDisplay('none');
                setDisplayOK('inline-block')
            }
            // otherwise success
            // open up input box
            // take input and output the encrypted
            // open up decrypt box
            // take input and output the decrypted original (if success)
            if(dd<10000)setSuccessD('inline-block'); 
            setFinalCryptoPairs({N, e, d:dd})
            if(dd<10000)setMainGenerator('none')
            return dd 
        } else {
            return 0 
        }
    }

    //------------------------------------- 
    // Auto generate must be moved to top
    // all vars must be recalculated to find d
    //-------------------------------------

    const LoadedRoute:React.FC<{}> = ({ ...rest }) => {
        return ( 
            loading ? 
            (<div> ... running algorithms ... </div>) : 
            (<div>done</div>)
        )
    }

    const autoGenerateD = ():number => {
        // d*e = 1 mod N 
        let dd:number=1; 
        let phiN = (primeArr[randoPrime1] - 1) * (primeArr[randoPrime2] - 1)

        if(e !== null){

            while( ((dd*Number(e)) % phiN !== 1) && dd<1000 ){
                // set loading icon 
                console.log('d -> ', (dd*Number(e)) % phiN)

                if( (dd*Number(e)) % phiN === 1 ){
                    console.log("FOUND D ",dd)
                    break
                }

                dd++

                if(dd>=1000){
                    console.log('TOO BIG! RESTARTING');
                    dd=1;
                }

            } // end while 
            
            
            console.log("Auto found D: ", dd, ' ', typeof dd); 
            setSuccessD('inline-block');
            setFinalCryptoPairs( {N, e, d:dd} );
            setMainGenerator('none');
            return +dd; // convert to number type 
            

        } else {
            return 0 
        }
    }
    //-------------------------------------

    return(
        
        <div>
            <div>
                
                <h1 style={{color:'white'}}>RSA Keys Generator</h1><br></br> 

                <div className='mainPrimeGen' style={{display:`${mainGenerator}`}}>
                    
                    <strong className='main_generator'>Do you want to generate manually or automatically?</strong><br></br>
                    <Button onClick={()=>handleManually()} color='default' variant='outlined'>Manually</Button>
                    <Button onClick={()=>handleAutomatically()} color='default' variant='outlined'>Automatically</Button>
                    <div> 
                        <button className="hover_buttons" onClick={()=>genRandomPrimes()} style={{display:`${randomPrimesDisplay}`}}>
                            <strong>Get Random Primes</strong>
                        </button> 
                        {/* <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div> */}
                        <button className="hover_buttons" onClick={()=>autoGenD()} style={{display:`${autoGenerateKeys}`}}>
                            <strong>Auto Generate</strong>
                        </button> 
                        { loading && <LoadedRoute></LoadedRoute> }
                    </div>

                    <div className='get_random_primes'>
                        <div> Prime 1: {primeArr[randoPrime1]} <br></br> </div>
                        <div> Prime 2: {primeArr[randoPrime2]} <br></br> </div>
                        <div> N: { primeArr[randoPrime1] * primeArr[randoPrime2] } <br></br> </div>
                        <div> &#x3D5;(N): { (primeArr[randoPrime1] - 1) * (primeArr[randoPrime2] - 1) } <br></br><br></br> </div> 
                    </div>
                    <div className='get_e'>
                        <button className="hover_buttons" onClick={()=>genE()} style={{display:`${genEDisplay}`}}>
                            <strong>Get E</strong>
                        </button> <br></br>
                        <div> e: {e} <br></br><br></br> </div>            
                    </div>

                    <div className='get_d'>
                        <button className="hover_buttons" onClick={()=>genD()} style={{display:`${genDDisplay}`}}>
                            <strong>Manual Get D</strong> 
                        </button> 
                        <div> d: {d} <br></br> </div>            
                    </div>

                    <Button onClick={()=>handleOK()} variant='outlined' style={{display:`${displayOK}`}}>OK</Button>
                    <br></br>

                </div>

                <div style={{display:`${successD}`}}>
                    <table className='get_random_primes'>
                        <th>
                            N
                        </th>
                        <tr>
                            <td>{primeArr[randoPrime1] * primeArr[randoPrime2]}</td>
                        </tr>

                    </table> <br></br>
                        
                    <table className='get_random_primes'>
                        <th>
                            Keys
                        </th>
                        <tr>
                            <td>E: {e}</td>
                        </tr>
                        <tr>
                            <td>D: {d}</td>
                        </tr>
                    </table> <br></br>


                </div>
            { autoGenerateKeys && <AutoGenKeys /> }

            </div>
        </div> 
    )
}

export default PrimeGen; 